# Streamlit
# Use QARetrieval to find informations about the Confluence knowledge base
# Enhanced with advanced features:
# - Conversation analysis
# - Response tracking
# - Question suggestion
# - Performance monitoring
# - Query history
# - Automatic reformulation

import streamlit as st
import time
import os
import sys
from pathlib import Path

# Ajouter le r√©pertoire parent au chemin de recherche Python
sys.path.append(str(Path(__file__).parent.parent))

# Import des modules personnalis√©s
from src.help_desk import HelpDesk
from src.auth import (
    logout,
    get_all_users,
    add_user,
    delete_user,
)
from src.features_integration import FeaturesManager

# Configuration de la page Streamlit - doit √™tre la premi√®re commande Streamlit
st.set_page_config(page_title="Assistant Confluence", page_icon="ü§ñ", layout="wide")


# Pas de cache pour forcer le rechargement √† chaque lancement
def get_model(rebuild_db=False):
    # Afficher un spinner pendant le chargement
    with st.spinner("Chargement du mod√®le RAG..."):
        # V√©rifier si le fichier index.faiss existe
        import sys
        from config import PERSIST_DIRECTORY

        # Afficher les informations de configuration pour le d√©bogage
        st.sidebar.expander("D√©bogage", expanded=False).write(
            f"""
            **Configuration**: 
        - Dossier de la base vectorielle: `{PERSIST_DIRECTORY}`
        - URL Confluence: `{os.getenv('CONFLUENCE_SPACE_NAME')}`
        - Cl√© d'espace: `{os.getenv('CONFLUENCE_SPACE_KEY')}`
        - Utilisateur: `{os.getenv('CONFLUENCE_EMAIL_ADRESS')}`
        - Cl√© API: `{'*'*5}{os.getenv('CONFLUENCE_PRIVATE_API_KEY')[-5:] if os.getenv('CONFLUENCE_PRIVATE_API_KEY') else 'Non d√©finie'}`
        """  # noqa
        )

        # V√©rifier que le dossier existe
        if not os.path.exists(PERSIST_DIRECTORY):
            st.warning(f"Le dossier {PERSIST_DIRECTORY} n'existe pas. Tentative de cr√©ation...")
            try:
                os.makedirs(PERSIST_DIRECTORY, exist_ok=True)
            except Exception as e:
                st.error(f"Erreur lors de la cr√©ation du dossier: {str(e)}")

        # V√©rifier si les fichiers d'index existent
        index_faiss_path = os.path.join(PERSIST_DIRECTORY, "index.faiss")
        index_pkl_path = os.path.join(PERSIST_DIRECTORY, "index.pkl")

        if not os.path.exists(index_faiss_path) or not os.path.exists(index_pkl_path):
            st.warning("Base de donn√©es vectorielle non trouv√©e. Reconstruction en cours...")
            rebuild_db = True
        else:
            st.success("Base de donn√©es vectorielle trouv√©e!")

        # Cr√©er le mod√®le
        try:
            model = HelpDesk(new_db=rebuild_db)
            return model
        except Exception as e:
            st.error(f"Erreur lors du chargement du mod√®le: {str(e)}")
            import traceback

            st.code(traceback.format_exc(), language="python")
            sys.exit(1)


# Initialisation de l'interface utilisateur
def main():
    # Ensure user is always authenticated
    # Even before rendering sidebar, force user auth
    if "user" not in st.session_state:
        # Create or retrieve admin user immediately
        email = os.getenv("CONFLUENCE_EMAIL_ADRESS") or "admin@auto.login"
        from src.auth import get_all_users, add_user

        # Check if user exists, create if needed
        users = get_all_users()
        user = next((u for u in users if u["email"] == email), None)

        if not user:
            add_user(email, "auto_generated_pwd", is_admin=True)
            users = get_all_users()
            user = next((u for u in users if u["email"] == email), None)

        if user:
            st.session_state["user"] = user
            st.session_state["user_id"] = f"user_{user['id']}"
            st.session_state["page"] = "chat"
        else:
            # This should never happen but just in case
            st.error("Critical error: Failed to create auto-login user")
            st.stop()

    # Sidebar for navigation and options
    with st.sidebar:
        st.image("https://img.icons8.com/color/96/000000/confluence--v2.png", width=100)
        st.title("Assistant Confluence")

        # Always display user info
        st.success(f"Connect√© en tant que: {st.session_state['user']['email']}")

        # Navigation principale
        st.subheader("Navigation")
        if st.button("Chat", key="nav_chat"):
            st.session_state["page"] = "chat"
            st.rerun()

        if st.button("Historique", key="nav_history"):
            st.session_state["page"] = "history"
            st.rerun()

        # Options d'administration
        if st.session_state["user"].get("is_admin"):
            st.divider()
            st.info("Statut: Administrateur")
            if st.button("Tableau de bord admin", key="nav_admin"):
                st.session_state["page"] = "admin"
                st.rerun()

            # Option pour reconstruire la base de donn√©es
            st.divider()
            st.subheader("Gestion de la base de donn√©es")

            # Ajouter un bouton pour forcer la reconstruction compl√®te
            if st.button("Reconstruire depuis Confluence", type="primary"):
                with st.spinner("Reconstruction de la base de donn√©es depuis Confluence en cours..."):
                    # Supprimer les fichiers existants
                    import shutil
                    from config import PERSIST_DIRECTORY

                    try:
                        if os.path.exists(PERSIST_DIRECTORY):
                            shutil.rmtree(PERSIST_DIRECTORY)
                            st.info(f"Dossier {PERSIST_DIRECTORY} supprim√© avec succ√®s.")
                        os.makedirs(PERSIST_DIRECTORY, exist_ok=True)
                    except Exception as e:
                        st.error(f"Erreur lors de la suppression du dossier: {str(e)}")

                    # Forcer le rechargement du mod√®le avec new_db=True
                    try:
                        st.cache_resource.clear()
                        # model = get_model(rebuild_db=True)
                        st.success("Base de donn√©es reconstruite avec succ√®s depuis Confluence!")
                        time.sleep(2)
                        st.rerun()
                    except Exception as e:
                        st.error(f"Erreur lors de la reconstruction: {str(e)}")
                        import traceback

                        st.code(traceback.format_exc(), language="python")

        # Bouton de d√©connexion (pour tous les utilisateurs)
        st.divider()
        if st.button("D√©connexion", key="nav_logout"):
            logout()

    # D√©terminer quelle page afficher - user is already authenticated at the beginning of main()
    if st.session_state.get("page") == "admin" and st.session_state["user"].get("is_admin"):
        admin_page()
    elif st.session_state.get("page") == "history":
        history_page()
    else:
        # Default to chat page
        chat_page()


def login_required(func):
    """D√©corateur pour v√©rifier si l'utilisateur est connect√©"""

    def wrapper(*args, **kwargs):
        if "user" not in st.session_state:
            # Auto-login instead of showing a warning
            email = os.getenv("CONFLUENCE_EMAIL_ADRESS") or "admin@auto.login"
            from src.auth import get_all_users, add_user

            # Quick setup of an admin user
            users = get_all_users()
            user = next((u for u in users if u["email"] == email), None)

            if not user:
                add_user(email, "auto_generated_pwd", is_admin=True)
                users = get_all_users()
                user = next((u for u in users if u["email"] == email), None)

            if user:
                st.session_state["user"] = user
                st.session_state["user_id"] = f"user_{user['id']}"
                st.session_state["page"] = "chat"
                # Continue with function execution after setting up the user
            else:
                st.error("Critical authentication error")
                st.stop()
                return None
        return func(*args, **kwargs)

    return wrapper


def admin_required(func):
    """D√©corateur pour v√©rifier si l'utilisateur est admin"""

    def wrapper(*args, **kwargs):
        # First ensure user is logged in with login_required decorator logic
        if "user" not in st.session_state:
            # Get or create admin user from .env
            email = os.getenv("CONFLUENCE_EMAIL_ADRESS") or "admin@auto.login"
            from src.auth import get_all_users, add_user

            users = get_all_users()
            user = next((u for u in users if u["email"] == email), None)

            if not user:
                # Always create as admin
                add_user(email, "auto_generated_pwd", is_admin=True)
                users = get_all_users()
                user = next((u for u in users if u["email"] == email), None)

            if user:
                st.session_state["user"] = user
                st.session_state["user_id"] = f"user_{user['id']}"
                st.session_state["page"] = "chat"
            else:
                st.error("Critical authentication error")
                st.stop()
                return None

        # Then check if user is admin (should always be true with our setup)
        if not st.session_state["user"].get("is_admin"):
            # Make them admin if they aren't already
            from src.auth import get_all_users, add_user

            email = st.session_state["user"]["email"]
            st.session_state["user"]["is_admin"] = True

        return func(*args, **kwargs)

    return wrapper


def login_page():
    """Auto-login function that skips the login UI entirely"""
    # Directly set up the user using Confluence credentials
    email = os.getenv("CONFLUENCE_EMAIL_ADRESS") or "admin@auto.login"
    from src.auth import get_all_users, add_user

    # Ensure user exists
    users = get_all_users()
    user = next((u for u in users if u["email"] == email), None)

    if not user:
        add_user(email, "auto_generated_pwd", is_admin=True)
        users = get_all_users()
        user = next((u for u in users if u["email"] == email), None)

    if user:
        # Set session state and go directly to chat
        st.session_state["user"] = user
        st.session_state["user_id"] = f"user_{user['id']}"
        st.session_state["page"] = "chat"
        # Force page refresh to apply changes
        st.rerun()
    else:
        st.error("Failed to initialize user session. Check your .env configuration.")
        st.stop()


@login_required
def chat_page():
    # R√©initialiser la page si n√©cessaire
    st.session_state["page"] = "chat"

    # Charger le mod√®le
    model = get_model()

    # Initialiser le gestionnaire de fonctionnalit√©s
    if "features_manager" not in st.session_state:
        user_id = st.session_state.get("user_id", f"user_{st.session_state['user']['id']}")
        st.session_state["features_manager"] = FeaturesManager(model, user_id)

    features = st.session_state["features_manager"]

    # Cr√©er la mise en page
    st.title("Assistant de Recherche Confluence")

    # Barre lat√©rale pour les options avanc√©es
    with st.sidebar:
        st.subheader("Options avanc√©es")
        show_suggestions = st.toggle("Suggestions de questions", value=True)
        show_feedback = st.toggle("Feedback sur les r√©ponses", value=True)

        # Historique des requ√™tes
        if st.button("Historique des requ√™tes"):
            st.session_state["page"] = "history"
            st.rerun()

    # Afficher l'interface principale
    st.subheader("Posez vos questions sur la documentation Confluence")

    # Initialiser l'historique des messages
    if "messages" not in st.session_state:
        st.session_state["messages"] = [
            {"role": "assistant", "content": "Bonjour ! Comment puis-je vous aider aujourd'hui ?"}
        ]

    # Afficher l'historique des messages
    for msg in st.session_state.messages:
        st.chat_message(msg["role"]).write(msg["content"])

    # V√©rifier s'il y a une question √† r√©utiliser depuis l'historique
    if "reuse_question" in st.session_state:
        prompt = st.session_state.pop("reuse_question")
        st.session_state.messages.append({"role": "user", "content": prompt})
        st.chat_message("user").write(prompt)

        # Traiter la question avec toutes les fonctionnalit√©s
        with st.spinner("Analyse en cours..."):
            result, sources = features.process_question(
                prompt, show_suggestions=show_suggestions, show_feedback=show_feedback
            )

        # Ajouter la r√©ponse aux messages
        response_content = result
        if sources:
            response_content += "\n\n" + sources

        st.session_state.messages.append({"role": "assistant", "content": response_content})

    # Interface de chat
    if prompt := st.chat_input("Posez votre question ici..."):
        # Ajouter la question
        st.session_state.messages.append({"role": "user", "content": prompt})
        st.chat_message("user").write(prompt)

        # Traiter la question avec toutes les fonctionnalit√©s
        with st.spinner("Analyse en cours..."):
            result, sources = features.process_question(
                prompt, show_suggestions=show_suggestions, show_feedback=show_feedback
            )

        # Ajouter la r√©ponse aux messages
        response_content = result
        if sources:
            response_content += "\n\n" + sources

        st.chat_message("assistant").write(response_content)
        st.session_state.messages.append({"role": "assistant", "content": response_content})


@login_required
def history_page():
    """Affiche la page d'historique des requ√™tes"""
    # R√©initialiser la page si n√©cessaire
    st.session_state["page"] = "history"

    # R√©cup√©rer le gestionnaire de fonctionnalit√©s
    if "features_manager" not in st.session_state:
        st.error("Erreur: Gestionnaire de fonctionnalit√©s non initialis√©")
        st.session_state["page"] = "chat"
        st.rerun()

    features = st.session_state["features_manager"]
    user_id = st.session_state.get("user_id", f"user_{st.session_state['user']['id']}")

    # Afficher l'historique des requ√™tes
    features.query_history.render_history_page(st, user_id)

    # Bouton de retour
    if st.button("Retour au chat", key="return_from_history"):
        st.session_state["page"] = "chat"
        st.rerun()


@admin_required
def admin_page():
    """Affiche la page d'administration"""
    st.title("Tableau de bord d'administration")

    # Cr√©er des onglets pour s√©parer les diff√©rentes fonctionnalit√©s
    tab1, tab2 = st.tabs(["Gestion des utilisateurs", "Analyse et performances"])

    with tab1:
        st.header("Gestion des utilisateurs")

        # Formulaire pour ajouter un utilisateur
        with st.expander("Ajouter un utilisateur", expanded=True):
            with st.form("add_user_form"):
                email = st.text_input("Email")
                password = st.text_input("Mot de passe", type="password")
                is_admin = st.checkbox("Administrateur")
                submit = st.form_submit_button("Ajouter")

                if submit and email and password:
                    success = add_user(email, password, is_admin)
                    if success:
                        st.success(f"Utilisateur {email} ajout√© avec succ√®s.")
                    else:
                        st.error(f"L'email {email} existe d√©j√†.")

        # Liste des utilisateurs
        st.subheader("Liste des utilisateurs")
        users = get_all_users()

        if users:
            # Cr√©er un tableau pour afficher les utilisateurs
            cols = st.columns([3, 2, 1, 1])
            cols[0].write("**Email**")
            cols[1].write("**Date de cr√©ation**")
            cols[2].write("**Admin**")
            cols[3].write("**Actions**")

            for user in users:
                cols = st.columns([3, 2, 1, 1])
                cols[0].write(user["email"])
                cols[1].write(user["created_at"])
                cols[2].write("Oui" if user["is_admin"] else "Non")

                # Ne pas permettre de supprimer l'utilisateur connect√©
                if user["id"] != st.session_state["user"]["id"]:
                    if cols[3].button("Supprimer", key=f"delete_{user['id']}"):
                        delete_user(user["id"])
                        st.success(f"Utilisateur {user['email']} supprim√©.")
                        st.rerun()
                else:
                    cols[3].write("(Vous)")
        else:
            st.info("Aucun utilisateur trouv√©.")

    with tab2:
        # V√©rifier si le gestionnaire de fonctionnalit√©s est initialis√©
        if "features_manager" in st.session_state:
            features = st.session_state["features_manager"]
            features.render_admin_dashboard(st)
        else:
            st.warning("Veuillez d'abord interagir avec le chatbot pour initialiser les fonctionnalit√©s d'analyse.")

    # Bouton de retour
    if st.button("Retour au chat"):
        st.session_state["page"] = "chat"
        st.rerun()


# Lancer l'application
if __name__ == "__main__":
    main()
